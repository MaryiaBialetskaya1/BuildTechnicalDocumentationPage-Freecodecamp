<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <main id="main-doc">
        <section class="main-section" id="Classes_and_objects">
            <header>Classes and objects</header>
            <article>
                <p>Classes are the most fundamental of C#'s types. A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit. A class provides a definition for instances of the class, also known as objects. Classes support inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</p>
                <p>New classes are created using class declarations. A class declaration starts with a header. The header specifies:</p>
                <ul>
                    <li>The attributes and modifiers of the class</li>
                    <li>The name of the class</li>
                    <li>The base class (when inheriting from a base class)</li>
                    <li>The interfaces implemented by the class</li>
                </ul>
                <p>The header is followed by the class body, which consists of a list of member declarations written between the delimiters { and }.</p>
                <p>
                    The following code shows a declaration of a simple class named Point:
                    <code>
                        public class Point
                        {
                            public int X { get; }
                            public int Y { get; }
                            public Point(int x, int y) => (X, Y) = (x, y);
                        }
                    </code>
                </p>
                <p>
                    Instances of classes are created using the new operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance. The following statements create two Point objects and store references to those objects in two variables:
                    <code>
                        var p1 = new Point(0, 0);
                        var p2 = new Point(10, 20);
                    </code>
                </p>
                <p>The memory occupied by an object is automatically reclaimed when the object is no longer reachable. It's not necessary or possible to explicitly deallocate objects in C#.</p>
            </article>
        </section>
        <section class="main-section" id="Type_parameters">
            <header>Type parameters</header>
            <article>
                <p>Generic classes define type parameters. Type parameters are a list of type parameter names enclosed in angle brackets. Type parameters follow the class name. The type parameters can then be used in the body of the class declarations to define the members of the class. In the following example, the type parameters of Pair are TFirst and TSecond:
                    <code>
                        public class Pair<TFirst, TSecond>
                            {
                                public TFirst First { get; }
                                public TSecond Second { get; }
                                public Pair(TFirst first, TSecond second) =>
                                (First, Second) = (first, second);
                            }
                    </code>
                </p>
                <p>
                    A class type that is declared to take type parameters is called a generic class type. Struct, interface, and delegate types can also be generic. When the generic class is used, type arguments must be provided for each of the type parameters:
                    <code>
                        var pair = new Pair<int, string>(1, "two");
                        int i = pair.First;     //TFirst int
                        string s = pair.Second; //TSecond string
                    </code>
                </p>
                <p>
                    A generic type with type arguments provided, like Pair<int,string> above, is called a constructed type.
                </p>
            </article>
        </section>
        <section class="main-section" id="Base_classes">
            <header>Base classes</header>
            <article>
                <p>A class declaration may specify a base class. Follow the class name and type parameters with a colon and the name of the base class. Omitting a base class specification is the same as deriving from type object. In the following example, the base class of Point3D is Point. From the first example, the base class of Point is object:
                    <code>
                        public class Point3D : Point
                        {
                            public int Z { get; set; }
                            public Point3D(int x, int y, int z) : base(x, y)
                            {
                                Z = z;
                            }
                        }
                    </code>
                </p>
                <p>
                    A class inherits the members of its base class. Inheritance means that a class implicitly contains almost all members of its base class. A class doesn't inherit the instance and static constructors, and the finalizer. A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member. In the previous example, Point3D inherits the X and Y members from Point, and every Point3D instance contains three properties, X, Y, and Z.
                </p>
                <p>An implicit conversion exists from a class type to any of its base class types. A variable of a class type can reference an instance of that class or an instance of any derived class. For example, given the previous class declarations, a variable of type Point can reference either a Point or a Point3D:
                    <code>
                        Point a = new(10, 20);
                        Point b = new Point3D(10, 20, 30);
                    </code>
                </p>
            </article>
        </section>
        <section class="main-section" id="Structs">
            <header>Structs</header>
            <article>
                <p>Classes define types that support inheritance and polymorphism. They enable you to create sophisticated behaviors based on hierarchies of derived classes. By contrast, struct types are simpler types whose primary purpose is to store data values. Structs can't declare a base type; they implicitly derive from System.ValueType. You can't derive other struct types from a struct type. They're implicitly sealed.
                    <code>
                        public struct Point
                        {
                            public double X { get; }
                            public double Y { get; }
                            public Point(double x, double y) => (X, Y) = (x, y);
                        }
                    </code>
                </p>
            </article>
        </section>
        <section class="main-section" id="Interfaces">
            <header>Interfaces</header>
            <article>
                <p>
                    An interface defines a contract that can be implemented by classes and structs. You define an interface to declare capabilities that are shared among distinct types. For example, the System.Collections.Generic.IEnumerable<T> interface defines a consistent way to traverse all the items in a collection, such as an array. An interface can contain methods, properties, events, and indexers. An interface typically doesn't provide implementations of the members it definesâ€”it merely specifies the members that must be supplied by classes or structs that implement the interface.
                </p>
                <p>Interfaces may employ multiple inheritance. In the following example, the interface IComboBox inherits from both ITextBox and IListBox.
                    <code>
                        interface IControl
                        {
                            void Paint();
                        }
                        interface ITextBox : IControl
                        {
                            void SetText(string text);
                        }
                        interface IListBox : IControl
                        {
                            void SetItems(string[] items);
                        }
                        interface IComboBox : ITextBox, IListBox { }
                    </code>
                </p>
                <p>Classes and structs can implement multiple interfaces. In the following example, the class EditBox implements both IControl and IDataBound.
                    <code>
                        interface IDataBound
                        {
                            void Bind(Binder b);
                        }
                        public class EditBox : IControl, IDataBound
                        {
                            public void Paint() { }
                            public void Bind(Binder b) { }
                        }
                    </code>
                </p>
                <p>When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type. For example:
                    <code>
                        EditBox editBox = new();
                        IControl control = editBox;
                        IDataBound dataBound = editBox;
                    </code>
                </p>
            </article>
        </section>
        <section class="main-section" id="Enums">
            <header>Enums</header>
            <article>
                <p>An Enum type defines a set of constant values. The following enum declares constants that define different root vegetables:
                    <code>
                        public enum SomeRootVegetable
                        {
                            HorseRadish,
                            Radish,
                            Turnip
                        }
                    </code>
                </p>
                <p>
                    You can also define an enum to be used in combination as flags. The following declaration declares a set of flags for the four seasons. Any combination of the seasons may be applied, including an All value that includes all seasons:
                    <code>
                        [Flags]
                        public enum Seasons
                        {
                            None = 0,
                            Summer = 1,
                            Autumn = 2,
                            Winter = 4,
                            Spring = 8,
                            All = Summer | Autumn | Winter | Spring
                        }
                    </code>
                </p>
            </article>
        </section>
    </main>
</body>
</html>